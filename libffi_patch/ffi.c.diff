--- ffi_orig.c	2014-04-26 02:45:12 +0900
+++ ffi.c	2014-09-06 12:07:54 +0900
@@ -40,6 +40,13 @@
 #include <stdlib.h>
 
 
+// ***** win32 result check functions *****
+#ifdef X86_WIN32
+static int is_result_on_stack_sub(ffi_type *rtype);
+static int is_result_on_stack(ffi_type *rtype);
+#endif
+
+
 /* ffi_prep_args is called by the assembly routine once stack space
    has been allocated for the function's arguments */
 
@@ -258,7 +265,53 @@
       break;
 
     case FFI_TYPE_STRUCT:
-#ifndef X86
+//#ifndef X86
+//      if (cif->rtype->size == 1)
+//        {
+//          cif->flags = FFI_TYPE_SMALL_STRUCT_1B; /* same as char size */
+//        }
+//      else if (cif->rtype->size == 2)
+//        {
+//          cif->flags = FFI_TYPE_SMALL_STRUCT_2B; /* same as short size */
+//        }
+//      else if (cif->rtype->size == 4)
+//        {
+//#ifdef X86_WIN64
+//          cif->flags = FFI_TYPE_SMALL_STRUCT_4B;
+//#else
+//          cif->flags = FFI_TYPE_INT; /* same as int type */
+//#endif
+//        }
+//      else if (cif->rtype->size == 8)
+//        {
+//          cif->flags = FFI_TYPE_SINT64; /* same as int64 type */
+//        }
+//      else
+//#endif
+//        {
+//#ifdef X86_WIN32
+//          if (cif->abi == FFI_MS_CDECL)
+//            cif->flags = FFI_TYPE_MS_STRUCT;
+//          else
+//#endif
+//            cif->flags = FFI_TYPE_STRUCT;
+//          /* allocate space for return value pointer */
+//          cif->bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);
+//        }
+#ifdef X86_WIN32
+      // ***** win32 result check *****
+      if (is_result_on_stack(cif->rtype)) {
+          if (cif->abi == FFI_MS_CDECL) {
+              cif->flags = FFI_TYPE_MS_STRUCT;
+          } else {
+              cif->flags = FFI_TYPE_STRUCT;
+          }
+          /* allocate space for return value pointer */
+          cif->bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);
+      } else {
+          cif->flags = FFI_TYPE_SINT64; /* same as int64 type */
+      }
+#else
       if (cif->rtype->size == 1)
         {
           cif->flags = FFI_TYPE_SMALL_STRUCT_1B; /* same as char size */
@@ -280,17 +333,12 @@
           cif->flags = FFI_TYPE_SINT64; /* same as int64 type */
         }
       else
-#endif
         {
-#ifdef X86_WIN32
-          if (cif->abi == FFI_MS_CDECL)
-            cif->flags = FFI_TYPE_MS_STRUCT;
-          else
-#endif
-            cif->flags = FFI_TYPE_STRUCT;
+          cif->flags = FFI_TYPE_STRUCT;
           /* allocate space for return value pointer */
           cif->bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);
         }
+#endif
       break;
 
     default:
@@ -312,16 +360,30 @@
       cif->bytes += (unsigned)ALIGN((*ptr)->size, FFI_SIZEOF_ARG);
     }
 
+//#ifdef X86_WIN64
+//  /* ensure space for storing four registers */
+//  cif->bytes += 4 * sizeof(ffi_arg);
+//#endif
+//
+//#ifndef X86_WIN32
+//#ifndef X86_WIN64
+//  if (cif->abi != FFI_STDCALL && cif->abi != FFI_THISCALL && cif->abi != FFI_FASTCALL)
+//#endif
+//    cif->bytes = (cif->bytes + 15) & ~0xF;
+//#endif
+#ifdef X86_WIN32
+    // ***** win32 add space *****
+    cif->bytes = ((cif->bytes + 15) & ~0xF) + 8;
+#else
 #ifdef X86_WIN64
-  /* ensure space for storing four registers */
-  cif->bytes += 4 * sizeof(ffi_arg);
-#endif
-
-#ifndef X86_WIN32
-#ifndef X86_WIN64
-  if (cif->abi != FFI_STDCALL && cif->abi != FFI_THISCALL && cif->abi != FFI_FASTCALL)
-#endif
+    /* ensure space for storing four registers */
+    cif->bytes += 4 * sizeof(ffi_arg);
     cif->bytes = (cif->bytes + 15) & ~0xF;
+#else
+    if (cif->abi != FFI_STDCALL && cif->abi != FFI_THISCALL && cif->abi != FFI_FASTCALL) {
+        cif->bytes = (cif->bytes + 15) & ~0xF;
+    }
+#endif
 #endif
 
   return FFI_OK;
@@ -851,5 +913,82 @@
 
 #endif
 
+
+
+
+
+// ***** win32 result check functions *****
+#ifdef X86_WIN32
+static int is_result_on_stack_sub(ffi_type *rtype)
+{
+  ffi_type *elem;
+  int i;
+
+  for (i = 0; rtype->elements[i] != NULL; ++i)
+    {
+      elem = rtype->elements[i];
+      if (elem->type == FFI_TYPE_STRUCT)
+        {
+          if (is_result_on_stack_sub(elem))
+            return 1;
+        }
+      else
+        {
+          int size = 0;
+          switch (elem->type)
+            {
+            case FFI_TYPE_UINT8:
+            case FFI_TYPE_SINT8:
+              size = ffi_type_uint8.size;
+              break;
+            case FFI_TYPE_UINT16:
+            case FFI_TYPE_SINT16:
+              size = ffi_type_sint16.size;
+              break;
+            case FFI_TYPE_INT:
+            case FFI_TYPE_UINT32:
+            case FFI_TYPE_SINT32:
+              size = ffi_type_uint32.size;
+              break;
+            case FFI_TYPE_UINT64:
+            case FFI_TYPE_SINT64:
+              size = ffi_type_uint64.size;
+              break;
+            case FFI_TYPE_POINTER:
+              size = ffi_type_pointer.size;
+              break;
+            case FFI_TYPE_FLOAT:
+              size = ffi_type_float.size;
+              break;
+            case FFI_TYPE_DOUBLE:
+              size = ffi_type_double.size;
+              break;
+            case FFI_TYPE_LONGDOUBLE:
+              size = ffi_type_longdouble.size;
+              break;
+            }
+          if (size < elem->size)
+            return 1;
+        }
+    }
+  return 0;
+}
+
+static int is_result_on_stack(ffi_type *rtype)
+{
+  if (rtype->size > 8)
+    return 1;
+
+  if (rtype->type == FFI_TYPE_STRUCT)
+    return is_result_on_stack_sub(rtype);
+  else
+    return 0;
+}
+#endif
+
+
+
+
+
 #endif /* !__x86_64__  || X86_WIN64 */
 
